# üîß PHASE 3 - GUIDE DE D√âPANNAGE

## üéØ Solutions aux probl√®mes de s√©curit√© et authentification

---

## ‚ö†Ô∏è ERREUR 1 : "JWT invalid or expired"

### üî¥ Sympt√¥mes
- Erreur 401 dans toutes les requ√™tes
- Message : `JWT invalid or expired`
- Impossible d'acc√©der aux donn√©es

### ‚úÖ Solutions

**C'est NORMAL si vous n'√™tes pas connect√© !**

**Solution A - Se connecter d'abord :**
```javascript
// Dans la console du navigateur
const { data, error } = await window.supabase.auth.signInWithPassword({
  email: 'test@crmpro2x.com',
  password: 'Test123456!'
});

console.log('Connexion:', { data, error });
```

**Solution B - V√©rifier la session :**
```javascript
const { data: { session } } = await window.supabase.auth.getSession();
console.log('Session active:', session);
```

Si `session` est `null`, vous devez vous reconnecter.

**Solution C - Rafra√Æchir le token :**
```javascript
const { data, error } = await window.supabase.auth.refreshSession();
console.log('Token rafra√Æchi:', { data, error });
```

### üß™ Test
Apr√®s connexion, essayez :
```javascript
const { data } = await window.supabase.from('clients').select('count');
console.log('Acc√®s OK:', data);
```

---

## ‚ö†Ô∏è ERREUR 2 : "Row Level Security policy violation"

### üî¥ Sympt√¥mes
- Erreur dans les requ√™tes : `new row violates row-level security policy`
- Code erreur : 42501
- Les requ√™tes INSERT/UPDATE/DELETE √©chouent

### ‚úÖ Solutions

**Solution A - V√©rifier que RLS est activ√© :**
1. Supabase ‚Üí Table Editor
2. S√©lectionnez la table probl√©matique
3. V√©rifiez le badge "RLS enabled" en haut √† droite

Si RLS n'est PAS activ√© :
```sql
ALTER TABLE nom_de_table ENABLE ROW LEVEL SECURITY;
```

**Solution B - V√©rifier les politiques :**
1. Supabase ‚Üí Authentication ‚Üí Policies
2. Cherchez les politiques pour votre table
3. V√©rifiez qu'elles existent

Si aucune politique :
- R√©ex√©cutez le script PHASE_3_RLS_SECURITY.sql

**Solution C - V√©rifier votre r√¥le utilisateur :**

Votre utilisateur doit exister dans la table `users` avec un r√¥le :
```sql
-- V√©rifier dans SQL Editor
SELECT id, email, role FROM users 
WHERE id = auth.uid();
```

Si vide, ajoutez l'utilisateur :
```sql
INSERT INTO users (id, email, role)
VALUES (
  auth.uid(), 
  'votre-email@example.com', 
  'user'
);
```

**Solution D - Comprendre la politique :**

Exemple : Vous essayez de modifier un client mais vous n'√™tes pas assign√©.

Politique :
```sql
CREATE POLICY "Assigned users can update clients"
ON clients FOR UPDATE
USING (auth.uid() = assigned_to);
```

‚Üí Vous devez √™tre l'utilisateur assign√© au client !

**Solution temporaire - D√©sactiver RLS (DEV UNIQUEMENT) :**
```sql
-- ‚ö†Ô∏è UNIQUEMENT EN D√âVELOPPEMENT LOCAL !
ALTER TABLE nom_de_table DISABLE ROW LEVEL SECURITY;
```

‚ö†Ô∏è **NE JAMAIS faire ceci en production !**

### üß™ Test
```javascript
// Test de cr√©ation avec les bonnes permissions
const { data, error } = await window.supabase
  .from('clients')
  .insert({
    name: 'Test Client',
    status: 'prospect',
    assigned_to: session.user.id // Important !
  })
  .select()
  .single();

console.log({ data, error });
```

---

## ‚ö†Ô∏è ERREUR 3 : "User not found in database"

### üî¥ Sympt√¥mes
- Authentification r√©ussit mais donn√©es utilisateur manquantes
- `auth.uid()` existe mais pas de ligne dans `users`
- Erreurs lors de l'utilisation de l'application

### ‚úÖ Solutions

**Le probl√®me :**
Supabase Auth (authentification) et votre table `users` (donn√©es) sont s√©par√©s !

**Solution A - Cr√©er l'utilisateur dans la table users :**

1. **R√©cup√©rer l'UUID de l'utilisateur :**
   - Supabase ‚Üí Authentication ‚Üí Users
   - Copiez l'UUID de l'utilisateur

2. **Ins√©rer dans la table users :**
   - Supabase ‚Üí Table Editor ‚Üí users ‚Üí Insert row
   - Remplir :
     ```
     id: [UUID copi√©]
     email: test@crmpro2x.com
     full_name: Utilisateur Test
     role: user
     ```

**Solution B - Automatiser avec un trigger (recommand√©) :**

Cr√©ez un trigger qui ajoute automatiquement l'utilisateur dans `users` lors de l'inscription :

```sql
-- Fonction qui cr√©e l'utilisateur dans users
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.users (id, email, role)
  VALUES (NEW.id, NEW.email, 'user');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger qui appelle la fonction
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

Maintenant, chaque nouvel utilisateur sera automatiquement ajout√© √† la table `users` !

**Solution C - V√©rifier et r√©parer :**

Script pour trouver les utilisateurs auth sans entr√©e dans users :

```sql
-- Trouver les utilisateurs manquants
SELECT au.id, au.email
FROM auth.users au
LEFT JOIN public.users pu ON au.id = pu.id
WHERE pu.id IS NULL;

-- Les ajouter (ajustez selon vos besoins)
INSERT INTO public.users (id, email, role)
SELECT au.id, au.email, 'user'
FROM auth.users au
LEFT JOIN public.users pu ON au.id = pu.id
WHERE pu.id IS NULL;
```

### üß™ Test
```javascript
// V√©rifier que l'utilisateur existe dans users
const { data: { user } } = await window.supabase.auth.getUser();
const { data: userData } = await window.supabase
  .from('users')
  .select('*')
  .eq('id', user.id)
  .single();

console.log('Utilisateur complet:', userData);
```

---

## ‚ö†Ô∏è ERREUR 4 : Politiques trop restrictives

### üî¥ Sympt√¥mes
- M√™me connect√©, certaines actions √©chouent
- Utilisateur admin ne peut pas acc√©der √† tout
- Erreur : "insufficient permissions"

### ‚úÖ Solutions

**Solution A - V√©rifier votre r√¥le :**
```javascript
const { data: { user } } = await window.supabase.auth.getUser();
const { data: userData } = await window.supabase
  .from('users')
  .select('role')
  .eq('id', user.id)
  .single();

console.log('Mon r√¥le:', userData.role);
```

Si vous √™tes `user` mais avez besoin d'√™tre `admin`, mettez √† jour :
```sql
UPDATE users 
SET role = 'admin' 
WHERE email = 'votre@email.com';
```

**Solution B - Modifier une politique trop stricte :**

Exemple : Permettre √† tous les utilisateurs authentifi√©s de lire les produits :

```sql
-- Supprimer l'ancienne politique
DROP POLICY IF EXISTS "Users can view products" ON products;

-- Cr√©er une nouvelle politique plus permissive
CREATE POLICY "Authenticated users can view products"
ON products FOR SELECT
USING (auth.uid() IS NOT NULL);
```

**Solution C - Ajouter une politique manquante :**

Si une action sp√©cifique √©choue, v√©rifiez qu'une politique existe pour cette action.

Exemple : Permettre aux users de cr√©er des t√¢ches :
```sql
CREATE POLICY "Users can create tasks"
ON tasks FOR INSERT
WITH CHECK (auth.uid() IS NOT NULL);
```

**Solution D - D√©boguer les politiques :**

Activer les logs d√©taill√©s :
```sql
-- Voir pourquoi une politique √©choue
SET client_min_messages TO DEBUG;

-- Votre requ√™te probl√©matique ici
SELECT * FROM clients WHERE id = 'xxx';
```

### üß™ Test
Testez chaque action CRUD :
```javascript
const tests = {
  read: await window.supabase.from('clients').select('*'),
  create: await window.supabase.from('clients').insert({name: 'Test'}),
  update: await window.supabase.from('clients').update({name: 'Updated'}).eq('id', 'xxx'),
  delete: await window.supabase.from('clients').delete().eq('id', 'xxx')
};

console.log('Tests CRUD:', tests);
```

---

## ‚ö†Ô∏è ERREUR 5 : Session expire trop vite

### üî¥ Sympt√¥mes
- D√©connexion fr√©quente
- JWT expire rapidement
- Utilisateur doit se reconnecter souvent

### ‚úÖ Solutions

**Solution A - Configurer le refresh automatique :**

Dans votre client Supabase (`src/integrations/supabase/client.ts`) :

```typescript
export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    persistSession: true,      // Persiste la session
    autoRefreshToken: true,     // Refresh automatique ‚úÖ
    detectSessionInUrl: true,
  }
});
```

**Solution B - Augmenter la dur√©e du JWT (Supabase Dashboard) :**

1. Supabase ‚Üí Authentication ‚Üí Settings
2. JWT Expiry : R√©glez sur `3600` (1 heure) ou plus
3. Sauvegardez

**Solution C - Impl√©menter un refresh manuel :**

```typescript
// Hook pour garder la session active
useEffect(() => {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    async (event, session) => {
      if (event === 'TOKEN_REFRESHED') {
        console.log('Token rafra√Æchi automatiquement');
      }
      
      if (event === 'SIGNED_OUT') {
        console.log('Session expir√©e');
        // Rediriger vers login
      }
    }
  );

  return () => subscription.unsubscribe();
}, []);
```

### üß™ Test
```javascript
// V√©rifier la dur√©e de vie du token
const { data: { session } } = await window.supabase.auth.getSession();
const expiresAt = new Date(session.expires_at * 1000);
console.log('Session expire √†:', expiresAt);
```

---

## ‚ö†Ô∏è ERREUR 6 : Impossible de se d√©connecter

### üî¥ Sympt√¥mes
- `signOut()` ne fonctionne pas
- Session reste active
- Utilisateur reste connect√©

### ‚úÖ Solutions

**Solution A - D√©connexion compl√®te :**
```javascript
// M√©thode recommand√©e
await window.supabase.auth.signOut();

// V√©rifier
const { data: { session } } = await window.supabase.auth.getSession();
console.log('Session apr√®s logout:', session); // Doit √™tre null
```

**Solution B - Nettoyer le localStorage :**
```javascript
await window.supabase.auth.signOut();
localStorage.clear(); // Nettoie tout
```

**Solution C - Forcer la d√©connexion :**
```javascript
// D√©connexion de toutes les sessions
await window.supabase.auth.signOut({ scope: 'global' });
```

### üß™ Test
```javascript
await window.supabase.auth.signOut();
const { data } = await window.supabase.from('clients').select('*');
console.log('Doit √©chouer:', data); // null si d√©connect√©
```

---

## ‚ö†Ô∏è ERREUR 7 : Email de confirmation non re√ßu

### üî¥ Sympt√¥mes
- Inscription r√©ussit mais email non re√ßu
- Utilisateur ne peut pas confirmer son compte
- Auto Confirm User n√©cessaire

### ‚úÖ Solutions

**Solution A - Activer Auto Confirm (DEV) :**

Lors de la cr√©ation d'utilisateur :
1. Authentication ‚Üí Users ‚Üí Add user
2. ‚úÖ Cochez "Auto Confirm User"

**Solution B - Configurer l'envoi d'emails (PROD) :**

1. Supabase ‚Üí Authentication ‚Üí Email Templates
2. Configurez SMTP ou utilisez Supabase Mailer
3. Testez l'envoi

**Solution C - Confirmer manuellement via SQL :**
```sql
-- Confirmer un utilisateur existant
UPDATE auth.users 
SET email_confirmed_at = NOW() 
WHERE email = 'user@example.com';
```

**Solution D - D√©sactiver la confirmation (DEV UNIQUEMENT) :**

1. Supabase ‚Üí Authentication ‚Üí Settings
2. Email ‚Üí Disable email confirmations
3. ‚ö†Ô∏è R√©activez en production !

---

## ‚ö†Ô∏è ERREUR 8 : Politique ne s'applique pas

### üî¥ Sympt√¥mes
- Politique cr√©√©e mais ne fonctionne pas
- Toujours les m√™mes erreurs de permission
- Modifications de politiques non prises en compte

### ‚úÖ Solutions

**Solution A - V√©rifier que la politique existe :**
```sql
-- Lister toutes les politiques d'une table
SELECT * FROM pg_policies WHERE tablename = 'clients';
```

**Solution B - Supprimer et recr√©er :**
```sql
-- Supprimer toutes les politiques d'une table
DROP POLICY IF EXISTS "policy_name" ON table_name;

-- Recr√©er depuis PHASE_3_RLS_SECURITY.sql
```

**Solution C - V√©rifier l'ordre des politiques :**

Les politiques sont √©valu√©es avec OR (pas AND).
Si UNE politique permet l'acc√®s, c'est OK.

```sql
-- Ces deux politiques permettent l'acc√®s si L'UNE OU L'AUTRE est vraie
Policy 1: auth.uid() = assigned_to
Policy 2: role = 'admin'
-- ‚Üí Un admin OU l'assign√© peut acc√©der
```

**Solution D - Rafra√Æchir le cache :**

1. D√©connectez-vous
2. Fermez tous les onglets
3. Reconnectez-vous
4. Testez √† nouveau

### üß™ Test
```sql
-- Tester une politique directement
EXPLAIN (ANALYZE, VERBOSE)
SELECT * FROM clients WHERE id = 'xxx';
```

---

## üìä COMMANDES DE DIAGNOSTIC

```sql
-- V√©rifier RLS activ√©
SELECT schemaname, tablename, rowsecurity 
FROM pg_tables 
WHERE schemaname = 'public';

-- Lister toutes les politiques
SELECT schemaname, tablename, policyname, cmd, qual 
FROM pg_policies 
WHERE schemaname = 'public';

-- V√©rifier l'utilisateur actuel
SELECT auth.uid(), auth.role();

-- Compter les politiques par table
SELECT tablename, COUNT(*) as nb_policies
FROM pg_policies 
WHERE schemaname = 'public'
GROUP BY tablename;
```

---

## üÜò DERNIER RECOURS

**Option 1 : R√©initialiser toutes les politiques**
```sql
-- ‚ö†Ô∏è SUPPRIME TOUTES LES POLITIQUES
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN 
        SELECT schemaname, tablename, policyname
        FROM pg_policies
        WHERE schemaname = 'public'
    LOOP
        EXECUTE 'DROP POLICY IF EXISTS "' || r.policyname || '" ON ' || r.schemaname || '.' || r.tablename;
    END LOOP;
END $$;

-- Puis r√©ex√©cuter PHASE_3_RLS_SECURITY.sql
```

**Option 2 : D√©sactiver RLS temporairement (DEV UNIQUEMENT)**
```sql
-- ‚ö†Ô∏è REND LA DB NON S√âCURIS√âE
ALTER TABLE clients DISABLE ROW LEVEL SECURITY;
-- R√©p√©tez pour chaque table
```

**Option 3 : Recr√©er le projet Supabase**

Si tout est cass√© :
1. Exportez vos donn√©es importantes
2. Cr√©ez un nouveau projet Supabase
3. R√©ex√©cutez Phase 1, 2, 3 depuis le d√©but

---

## ‚úÖ CHECKLIST DE V√âRIFICATION

Avant de demander de l'aide :

- [ ] RLS activ√© (`SELECT * FROM pg_tables WHERE rowsecurity = true`)
- [ ] Politiques cr√©√©es (`SELECT COUNT(*) FROM pg_policies`)
- [ ] Utilisateur dans auth.users ET public.users
- [ ] R√¥le correct dans public.users
- [ ] Session active (`auth.getSession()`)
- [ ] Token valide (pas expir√©)
- [ ] Logs v√©rifi√©s (Supabase ‚Üí Logs)

---

**La s√©curit√© est complexe mais essentielle ! Prenez votre temps ! üîí**